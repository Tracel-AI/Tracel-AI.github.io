<!DOCTYPE html><html lang="en" ><head ><script data-hk="0-0-0-0-0-0-0-0-0-0-0" src="/analytics.js"></script><script data-hk="0-0-0-0-0-0-0-0-0-0-1" async src="https://www.googletagmanager.com/gtag/js?id=G-S6CQMW5DNY"></script><meta data-sm="0-0-0-0-0-0-0-0-0-0-2-0" charset="utf-8"/><meta data-sm="0-0-0-0-0-0-0-0-0-0-3-0" name="viewport" content="width=device-width, initial-scale=1"/><link data-sm="0-0-0-0-0-0-0-0-0-0-4-0" rel="manifest" href="/manifest.webmanifest"/><meta data-sm="0-0-0-0-0-0-0-0-0-0-5-0" name="description" content="Burn Unstoppable Rusty Neurons"/><link data-sm="0-0-0-0-0-0-0-0-0-0-6-0" rel="icon" href="/favicon.ico" type="image/png" sizes="16x16"/><link data-sm="0-0-0-0-0-0-0-0-0-0-7-0" rel="apple-touch-icon" href="/pwa-192x192.png" sizes="192x192"/><meta data-sm="0-0-0-0-0-0-0-0-0-0-8-0" name="theme-color" content="#202A37"/><title data-sm="0-0-0-0-0-0-0-0-0-0-9-0">Burn - Deep Learning Framework</title><meta data-sm="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-19-0" property="og:type" content="article"/><meta data-sm="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-20-0" property="og:title" content="Autotune for GPU Kernels: Ensuring Consistent Peak Performance"/><meta data-sm="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-21-0" property="og:description" content="Crafting high-performance GPU kernels for common deep learning operations, such as matrix multiplication (matmul) and reduction, requires finesse. The speed of these kernels varies depending on input shapes and the GPU device in use, meaning the fastest one may change based on the context. In Burn, Autotune automates the task of dynamically performing kernel selection, allowing one to create a plethora of kernel variations with confidence that the best-performing one will be executed in every situation."/><meta data-sm="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-22-0" property="og:author" content="Louis Fortier-Dubois"/><meta data-sm="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-23-0" property="og:image" content="/blog5.jpeg"/><meta data-sm="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-24-0" property="article:published_time" content="2023-12-15T18:00:00.000Z"/><link rel="modulepreload" href="/assets/autotune-for-gpu-kernels-1c9d9b5c.js"><link rel="modulepreload" href="/assets/entry-client-19a0a2a8.js"><link rel="stylesheet" href="/assets/entry-client-512d4306.css"><link rel="modulepreload" href="/assets/index-f3e0ea94.js"><link rel="modulepreload" href="/assets/index-a59e1184.js"><link rel="modulepreload" href="/assets/blogs-2d592072.js"><link rel="modulepreload" href="/assets/page-54998af4.js"><link rel="modulepreload" href="/assets/index-4d32178d.js"></head><body class="overflow-x-hidden " ><!e0-0-0-0-0-0-0-0-0-1-0-0-0><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-0" class="dark"><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-0" class="bg-gray-800 min-h-[100vh] w-full flex flex-col"><nav class="fixed w-full px-10 py-5 z-50 flex items-center text-gray-50 font-semibold transition-colors false"><a href="/" class="text-3xl hover:scale-110 transition-all">Burn</a><ul class="ml-auto flex space-x-12 text-xl"><li class="hover:scale-110 transition-all"><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-1-0" link="true" href="/demo" class="text-white inactive" >Demo</a></li><li class="hover:scale-110 transition-all"><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-2-0" link="true" href="/blog" class="text-white active" aria-current="page">Blog</a></li><li class="hover:scale-110 transition-all"><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-3-0" target="_blank" rel="noreferrer" href="https://burn.dev/book/" class="text-white">Book</a></li><li class="hidden sm:block"><iframe src="https://ghbtns.com/github-btn.html?user=tracel-ai&amp;repo=burn&amp;type=star&amp;count=true&amp;size=large" width="170" height="30" title="GitHub"></iframe></li></ul></nav><!--#--><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-4-0-0" id="star-0" class="absolute bg-[#EBC65D] rounded-full invisible sm:visible"></div><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-4-0-1" id="star-1" class="absolute bg-[#EBC65D] rounded-full invisible sm:visible"></div><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-4-0-2" id="star-2" class="absolute bg-[#EBC65D] rounded-full invisible sm:visible"></div><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-4-0-3" id="star-3" class="absolute bg-[#EBC65D] rounded-full invisible sm:visible"></div><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-4-0-4" id="star-4" class="absolute bg-[#EBC65D] rounded-full invisible sm:visible"></div><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-4-0-5" id="star-5" class="absolute bg-[#EBC65D] rounded-full invisible sm:visible"></div><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-4-0-6" id="star-6" class="absolute bg-[#EBC65D] rounded-full invisible sm:visible"></div><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-4-0-7" id="star-7" class="absolute bg-[#EBC65D] rounded-full invisible sm:visible"></div><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-4-0-8" id="star-8" class="absolute bg-[#EBC65D] rounded-full invisible sm:visible"></div><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-4-0-9" id="star-9" class="absolute bg-[#EBC65D] rounded-full invisible sm:visible"></div><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-4-0-10" id="star-10" class="absolute bg-[#EBC65D] rounded-full invisible sm:visible"></div><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-4-0-11" id="star-11" class="absolute bg-[#EBC65D] rounded-full invisible sm:visible"></div><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-4-0-12" id="star-12" class="absolute bg-[#EBC65D] rounded-full invisible sm:visible"></div><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-4-0-13" id="star-13" class="absolute bg-[#EBC65D] rounded-full invisible sm:visible"></div><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-4-0-14" id="star-14" class="absolute bg-[#EBC65D] rounded-full invisible sm:visible"></div><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-18" class="flex justify-center w-full pt-20 bg-gradient-to-b from-[#202124] to-gray-800"><div class="w-full max-w-5xl mb-10 mx-3"><!--#--><!--/--><!--#--><!--/--><!--#--><!--/--><!--#--><!--/--><!--#--><!--/--><!--#--><!--/--><div class="mb-3"><p class="text-white font-bold text-xl px-2"><a href="/" class="hover:text-[#edc567]">burn</a><!--#--><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-25-0"><span> · </span><a href="/blog" class="hover:text-[#edc567]">blog</a></span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-25-1"><span> · </span><a href="/blog/autotune-for-gpu-kernels" class="hover:text-[#edc567]">autotune-for-gpu-kernels</a></span><!--/--></p></div><article class="blog rounded-lg bg-white/5 pt-4"><div><h1 class="px-3 sm:px-8">Autotune for GPU Kernels: Ensuring Consistent Peak Performance</h1><div class="px-3 pb-4 sm:px-8"><img class="h-48 w-full rounded-lg mr-3 object-cover object-top" src="/blog5.jpeg" alt="Space digital art generated by stable diffusion."></div><div class="flex px-3 sm:px-8"><div class="flex"><div class="h-5 w-5 i-mdi-clipboard-text-clock"></div><span class="px-2">Fri Dec 15 2023</span></div><!--#--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-26-0" class="pl-2 flex" href="https://x.com/louisfd94" target="_blank"><div class="h-5 w-5 i-mdi-account-edit"></div><span class="px-2">Louis Fortier-Dubois</span></a><!--/--></div></div><div class="pb-4 px-3 sm:px-8"><div class="border-t-2 border-gray-900 my-6"></div><!--#--><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-0"><h2>Introduction</h2><p>At the lowest level of abstraction of a deep learning framework lie the kernels. <i>Kernel</i> is a fancy word to describe an algorithm that accomplishes a task of relative simplicity on a tensor and that can be used in a broad range of contexts, like for instance a matrix multiplication (referred to as Matmul hereafter). These algorithms being the most basic building blocks, they often find themselves in the hot loop of an AI model and it's primordial that they execute as fast as possible. That is why their computation is often delegated to the GPU, which is usually faster on highly parallelizable problems like tensor operations, provided their excentricities are respected.</p><p>Indeed, there are many types of GPUs, all with their own cache size, number of registers, etc. As a result, some kernel implementations may run better on some GPUs than others <!--#--><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-1-1" class="reference px-1">[<!--#--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-1-0" class="hover:text-[#69b8e1]" href="#reference-1">1</a><!--/-->]</span><!--/-->. Add to that the fact that some kernels are better on some tensor shapes, as we will see with the Reduction algorithm.</p><p>Selecting the appropriate kernel for a given task, depending on the device and the shape, can quickly become a cumbersome task. Hardcoding the choice may pose two significant issues: first, it may not scale well in the future, and second, it might be inaccurate due to unforeseen factors not taken into consideration.</p><p>This is why, in Burn, we have chosen to automate the kernel selection process so that the best kernel is always selected, regardless of the device it runs on, the shape of the input, or any other consideration that is relevant for a specific kernel. We call this process Autotune.</p><p>After defining Autotune and explaining how we integrated it in Burn, we will look at how it simplifies the kernel selection for two common GPU operations: Reduction and Matmul.</p><h2>What's Autotune?</h2><p>You may recognize the word <i>Autotune</i> from the music industry, where Autotune was at first a software by Antares <!--#--><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-2-1" class="reference px-1">[<!--#--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-2-0" class="hover:text-[#69b8e1]" href="#reference-2">2</a><!--/-->]</span><!--/--> that can adjust a singer's pitch to a precise note in real time. It had such a high impact that the word is now often used for any such pitch-correcting algorithm. If you have a shaky voice -like me-, you will find Autotune to be a life saver when singing. In computer science, Autotune is also a correcting process happening at runtime. Instead of adjusting to a specific voice, it adjusts to a specific machine -your laptop, for instance. And instead of fixing the pitch, it fixes the execution time.</p><p>It's particularly relevant in deep learning simply because compute efficiency is such a big deal in that field, although in theory it could be used in any system where high performance is key. To be clear, it is not about tuning hyperparameters or anything that can change an AI model's accuracy or training convergence. It's only about selecting the fastest kernel among kernels that would all output the same result anyway.</p><p>Now, how does it work? It's actually rather simple: the first time you encounter an autotunable operation on a specific input when running your model on your machine, it will actually launch the operation on all kernels that are registered for Autotune, benchmark their execution time, and keep the fastest one in a cache for subsequent calls to that operation in similar settings.</p><p>As you can guess, any autotuning strategy adds some overhead for the first calls, the goal being to save as much time as possible in the long run. We've picked a straightforward strategy that is guaranteed to adapt directly to any hardware, as being portable is one of our main objectives. Also, we want Autotune to work with automatic kernel fusion, which creates never seen before kernels just-in-time for highly specialized task. Tuning by hand is just not possible in this dynamic context.</p><h2>Autotune in Burn</h2><p>In a previous blogpost <!--#--><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-3-1" class="reference px-1">[<!--#--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-3-0" class="hover:text-[#69b8e1]" href="#reference-3">3</a><!--/-->]</span><!--/-->, I presented Burn-Compute's architecture and I mentioned that Autotune was a part of it. As Burn-Compute is a reusable basis for all of our in-house backend, it means that Autotune will by default be part of our future backends. At the moment, we use it only on our WGPU backend, but it will be trivial to enhance our envisaged CUDA backend with it.</p><p>The subtlety of Autotune lies in the key used to cache kernels. If it summarizes the setting in which the kernel is needed in a way that is too precise, then there will be cache misses. For instance, an operation on matrices of shapes <i>231x231</i> or<i>233x233</i> has an extremely high probability of being optimal with the same kernel, so we should not run benchmarks for both. But if we encouter the shape <i>32x1024</i> afterwards, it may behave very differently.</p><p>More subtle yet, if we meet the shape <i>512x512</i> (512 is a power of 2, therefore a very "round" number in computer science), then maybe some kernel will be very fast; but then on a <i>512x511</i>matrix, the same kernel may need to add some padding first to transform it into a round <i>512x512</i> matrix with zeros at the end of each row. Adding those zeros means shifting all rows, which is a very costly operation.</p><p>This is of course very dependant of the nature of the operation. As we will see, the padding problem appears in Matmul but not in Reduction. In Burn, we therefore chose to make the key a custom trait implementation, customizable for every operation in every backend. Here are for instance our keys for the operations we will look at in the next sections:</p><!--#--><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-4-0" class="py-2"><pre class="border-2 border-gray-900 shadow rounded-lg w-full max-w-full"><code id="SNftvMnkqZNsmt_AwBXFF" class="language-rust">pub struct ReduceAutotuneKey {
    reduce_dim_length: usize, // Dimension on which we reduce (closest power of 2)
    reduce_dim_stride: usize, // Stride of reduce dimension (for data locality)
    others_product: usize,    // Product of all other dimensions (closest power of 2)
}
</code></pre></div><!--/--><!--#--><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-5-0" class="py-2"><pre class="border-2 border-gray-900 shadow rounded-lg w-full max-w-full"><code id="WTTIL4l98VsAJxTMUX5IH" class="language-rust">pub struct MatmulAutotuneKey {
    round: bool,            // True when all matmul dims are multiples of tile size
    broadcast: bool,        // True when there are differences in inputs batch size
    anchored_m: usize,      // M dimension (closest power of 2)
    anchored_k: usize,      // K dimension (closest power of 2)
    anchored_n: usize,      // N dimension (closest power of 2)
    anchored_batch: usize,  // Number of batches (closest power of 2), topped at 256
}
</code></pre></div><!--/--><p>Since the cache is always local in our current implementation, we do not bother keeping the device information in the key, although it may be included in the future.</p><p>Of note, we do not force Autotune to run all benchmarks on the actual input for which we request a kernel. Rather, we choose a random input on some shape that is representative of the key. For instance, we know that the execution time of our Matmul kernels always scales linearly with the batch size. If we need to run thousands of batches in the model, running Autotune on that batch size would take way more time than actually necessary, for the same information gain.</p><p>Also, if for instance all inputs between <i>512x512</i> and<i>1024x1024</i> shared the same key, should we run benchmarks on<i>1024x1024</i> which would likely take longer, or on <i>512x512</i> for shorter Autotune time, but at the risk of results being not too reliable at the higher end of the interval? We believe a representant, such as the median size <i>768x768</i> would be a great choice. We haven't yet explored the idea of a median representant yet in Burn, but it would certainly be interesting to measure how much more precise Autotune would become.</p><h2>Tensor Operations on GPU</h2><p>Remember how I argued that Autotune was a necessity: tensor operation kernels, in particular GPU ones, have execution speeds which highly depend on the system in use and input tensor shapes. In my personal experience, I find the impact of the tensor shape to be understandable, but the impact of the device less predictable -that's why I'm so happy to leave it in the hands of Autotune.</p><p>Using Reduction and Matmul as examples, we will see how GPU concepts related to input specifications have an impact on what is the right kernel to choose.</p><p>Since comparing devices is not the objective here, but rather the impact of input shape, all benchmarks I will present are run on my personal laptop (MacBook Pro's Apple M2 Pro 19-Core integrated graphics card, with Metal 3 API), using Burn's WGPU backend.</p><h3>Dividing the Workload</h3><p>We will look at some fundamental concepts of GPU computing, using the WebGPU nomenclature, which differ somewhat from that of CUDA. First, the computation is divided into a <i>grid</i>, which is a collection of <i>workgroups</i> which are themselves collections of <i>invocations</i>.</p><div class="flex justify-center"><img class="w-full center my-6 border-2 bg-white rounded" src="/autotune/grid.svg"></div><p>The grid is an arbitrarily long collection of workgroups. Typically, if a tensor has <i>n</i> elements and one workgroup is able to process <i>m</i> of them, then the grid consists of <i>n/m</i> workgroups. The grid's role is to ensure that the whole computation is carried, despite the fact that workgroups have limited sizes. The grid does not guarantee any order nor parallelism between workgroup computations, therefore we must consider all workgroups to work in silos.</p><p>It's <i>within</i> a workgroup that things get interesting. A workgroup is a fixed-size collection of invocations, which are essentially threads (in Burn we often launch 1024 invocations per workgroup). These threads all work at the same time on the GPU and can share data through a shared memory which leverages the GPU cache. They can also be synchronized with a barrier if needed.</p><h3>Important Considerations of GPU Algorithm Design</h3><p>When writing a GPU kernel, for instance using the WGSL (Web GPU Shading Language) <!--#--><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-6-1" class="reference px-1">[<!--#--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-6-0" class="hover:text-[#69b8e1]" href="#reference-4">4</a><!--/-->]</span><!--/--> as we do in our WGPU backend, you write only the code for one invocation. By using its <i>workgroup id</i> in the grid and <i>invocation id</i> in the workgroup, you can compute what specific tensor input and output elements this invocation should be working on.</p><p>Some important GPU concepts can have a high impact on the execution speed in different settings:</p><ul class="list-disc px-8 text-xl pb-8"><li>The <i>shared memory</i> allows for communication across threads, but not across workgroups. Therefore, if some elements of the input tensor must interact together, they should be managed by the same workgroup. This memory is also closer than the global memory where the input lies, so if a value must be fetched several times (by different threads of the same workgroup), it's probably worth saving it in shared memory.</li><br><li>One must <i>avoid concurrency errors</i>, both across invocations of a workgroup and across the grid, when writing results. While CUDA offers atomic write primitives <!--#--><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-7-1" class="reference px-1">[<!--#--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-7-0" class="hover:text-[#69b8e1]" href="#reference-5">5</a><!--/-->]</span><!--/--> which forbids two threads to add to a value at the same time, Web GPU does not afford us with this luxury, making it more delicate for threads to collaborate on the same output cells.</li><br><li><i>Memory coalescing</i> is something that can happen in GPUs, which I personally find magical: if several threads of adjacent IDs access the memory in adjacent spaces at the same time, the GPU can perform a single memory reading transaction for all of them. When writing GPU kernels, maximizing memory coalescing should be a goal. However, verifying its occurrence can be subtle, and it is precisely the type of aspect that can vary across different devices.</li><br><li>Somewhat related to that is the concept of <i>branch divergence</i>, which must be minimized. Branch divergence occurs when threads within a workgroup do not take the same path in the code, usually because of an <code>if</code> statement. The best example I can give is the one I mentioned earlier when I said a kernel can be very good on <i>512x512</i> shapes but poor on <i>512x511</i>. Suppose we have 64 threads working in parallel. If they operate in the middle of the matrix, there is no issue. However, when positioned on the edge, in the rounded case, the 64 threads will operate on indices 448 to 511, whereas in the truncated shape, they should cover indices 448 to 510 (a total of 63 values). The 64th thread can either: do a computation anyway on the data that follows, which will very likely lead to corrupted data, or go through an if to <i>not</i> do the computation like the others. This typically breaks all hopes for good memory coalescing within that workgroup, and threads have to wait for each other to be synchronized again. This is why it may (or may not) be best to pad the 511 elements row with a zero to reach a round number and avoid the need for <code>if</code> statements.</li></ul><h2>Reduction</h2><p>In the textbook 1-dimensional case, reducing means computing one value from a whole vector, leveraging the associativity of an underlying binary operation. Many variations exist (sum, product, maximum, etc.) but often share the same algorithmic structures. For instance, [12, 3, 5, 4, 15, 2] can be reduced to 41 in the sum case, or to 15 for the maximum. Many different strategies exist, some with a simple for loop on all values, and some that use recursivity to leverage parallelism in a divide-and-conquer fashion <!--#--><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-8-1" class="reference px-1">[<!--#--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-8-0" class="hover:text-[#69b8e1]" href="#reference-6">6</a><!--/-->]</span><!--/-->.</p><p>In the N-dimensional case, we typically reduce one dimension, going for instance from a <i>MxKxN</i> tensor to a <i>1xKxN</i> one when the reduce dimension is 0. In that case, we reduce M values together, KxN times. We will call the M values that must be reduced together a <i>reduce column</i>. In the figure below, the green block is the ouptputted <i>KxN</i> tensor, and the purple block is one of the reduce columns and consists of M elements. For visualization I've included only one reduce column, but there are in fact one for each element of the output tensor.</p><div class="flex justify-center"><img class="w-96 my-6 border-2 bg-white rounded" src="/autotune/reduce_explained.svg"></div><p>What is important here is that in the 0th dimension, the <i>M</i> values of a reduce column fundamentally need to interact together. Therefore, those values cannot be spread across different workgroups, since they would not be able to share information. On the other hand, each of the <i>KxN</i> reduce columns can be treated totally independantly from one another.</p><h3>One Invocation per Reduce Column</h3><p>Our first reduce kernel always gives the responsibility of computing a whole reduce column to only one <i>invocation</i>, which only executes a for loop on the whole reduce column. This may be a lot of computing for one thread when M is large, but this maximizes parallelization across the threads, who can all work in a well-vectorized way. Also, there is no risk of concurrency error as each output value is managed by only one thread.</p><div class="flex justify-center"><img class="w-96 my-6 border-2 bg-white rounded" src="/autotune/reduce_invocation.svg"></div><p>In the above, workgroups are separated by solid lines and invocations by dashed lines.</p><h3>One Workgroup per Reduce Column</h3><p>Our second reduce kernel rather gives the responsability of a reduce column to one <i>workgroup</i>. For large M, threads can work together through the shared memory to compute one reduce column much more quickly. Again, in the figure below, workgroups are separated by solid lines and invocations by dashed lines.</p><div class="flex justify-center"><img class="w-96 my-6 border-2 bg-white rounded" src="/autotune/reduce_workgroup.svg"></div><p>There are however two caveats:</p><ul class="list-disc px-8 text-xl pb-8"><li>If the other dimensions are large, the grid must consist of a lot of workgroups. Launching many workgroups is much slower than launching many threads.</li><li>When computing a reduce column, threads can use a divide-and-conquer method. However, as the column gets reduced, more and more threads become idle, likely causing branch divergence.</li></ul><h3>Autotuning Reduction</h3><p>Let's see what Autotune says about it. The following benchmarks consider two very different scenarios of reduction. In both examples, the first line is the Autotune key, the following two give the median computation time over a few executions, and the last line gives the selected, fastest kernel.</p><!--#--><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-9-0" class="py-2"><pre class="border-2 border-gray-900 shadow rounded-lg w-full max-w-full"><code id="aLxBDzIoZ3wbTxZsb5tMR" class="language-">Reduce - reduce_dim_length: 2048 reduce_dim_stride: 1024 others_product: 1024
OneColumnPerInvocationReduce&lt;f32, 3> => 8.98ms
OneColumnPerWorkgroupReduce&lt;f32, 3> => 3.88ms
Fastest: OneColumnPerWorkgroupReduce&lt;f32, 3></code></pre></div><!--/--><!--#--><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-10-0" class="py-2"><pre class="border-2 border-gray-900 shadow rounded-lg w-full max-w-full"><code id="jTxUzebob4OG4f3-Tf9Lh" class="language-">Reduce - reduce_dim_length: 32 reduce_dim_stride: 1 others_product: 65536
OneColumnPerInvocationReduce&lt;f32, 3> => 1.36ms
OneColumnPerWorkgroupReduce&lt;f32, 3> => 19.01ms
Fastest: OneColumnPerInvocationReduce&lt;f32, 3>
</code></pre></div><!--/--><p>In the first example, the reduce dimension is much larger than the product of all others, therefore it makes sense to use one workgroup on each column. The difference in time is also due to the large reduce_dim_stride which forbids memory coalescing to occur. In the second example, assigning one column per workgroup would mean creating tens of thousands of workgroups, each with too many threads, and is therefore very slow in comparison to creating 65536 threads who work independantly.</p><h2>Matmul</h2><p>Let's move on to our second operation. The point here is not to explain matrix multiplication in detail but to understand its complexity with regards to its inputs. On 2-dimensional input tensors (which are simply matrices), the result of a matrix A of size <i>MxN</i> times a matrix B of size<i>KxN</i> is an <i>MxN</i> output matrix C. In C, all values are the sum of K multiplications of an element of A with an element of B. On N-dimensional tensors, all other dimensions than the last two are simply batch dimensions, which can be seen as other unrelated instances of the kernel. For that reason, we will assume 2-dimensional tensors in the following explanations.</p><p>The computation of one output element depends on many elements of the inputs. This makes it impossible to make several threads work on a single output element without just repeating work. For that reason, all our kernels have each thread responsible of one output element (contrarily to our second reduce kernel).</p><p>Since all the pair-wise multiplications (one specific element of A with one element of B) are uniquely used - we cannot hope to reuse intermediate computation results several times. Therefore the algorithm must necessarily take at least <i>(size of C)xK = MxNxK</i> computation steps.</p><h2>Naive Approach (with Memory Coalescing)</h2><p>The naive approach simply consists in launching one invocation per output element. Then, each thread iteratively reads values from a row of A and from a column of B like in the figure below. The secret ingredient of this kernel is memory coalescing. Conceptually, if threads of the same workgroup with ids 0, 1, 2 and 3 read from memory cells i, i+1, i+2, i+3 at the same time, these read operations can be done all at once. Repeat this pattern everywhere and you get a pretty efficient kernel, considering its simplicity.</p><div class="flex justify-center"><img class="w-96 my-6 border-2 bg-white rounded" src="/autotune/matmul.svg"></div><p>However, this approach does not use the GPU cache intelligently.</p><h3>Padded Tiling 2D Approach</h3><p>The tiling approach is all about saving time through the use of shared memory, which normally lies in the GPU cache and is way faster to access than the inputs. Like mentioned earlier, all pair-wise multiplications are unique, but a single element of A (or B) is used by many threads, many of which in the same workgroup. We can leverage this.</p><p>In the tiling 2D kernel, we divide both input matrices into fixed-size tiles, and we also prepare one tile-size shared memory per input matrix. Working in synchronization with other invocations from its workgroup, a thread first contributes to fill the shared memory with the current input tile, then achieves all the partial computations needed for the output element it is responsible of, helping itself to values in the shared memory that have been loaded by his sibling threads. Then the process is repeated for all the tiles along the inner product dimension, to complete the computation of the output value.</p><p>I'm leaving out a lot of details as this gets very technical; more details and schemas can be found in <!--#--><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-11-1" class="reference px-1">[<!--#--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-11-0" class="hover:text-[#69b8e1]" href="#reference-7">7</a><!--/-->]</span><!--/-->. The important thing to realize is that we add steps for loading values from the global memory to the GPU cache, relying on thread synchronization within a workgroup, in order to gain some data locality when performing the actual additions and multiplications.</p><p>As I said, the tiles have fixed sizes, which are configurable, but the optimal number depends on the GPU architecture. Let's say we fix it to 64. Then any input size that is not a multiple of 64 will cause problems, because the last threads in the last tile may wrongly read from the row after theirs.</p><p>Hence the need for padding. If the last threads just read zeros instead of the values of the following row, they can do their computation like the other threads but with a value of zero, which will benignly add zero to the output.</p><h3>Unpadded Tiling 2D Approach</h3><p>Padding can be extremely costly because it changes the data layout: A new tensor allocation must occur where all rows must be shifted in order to insert zeros in between. In the following picture, we get from a <i>3x3</i> tensor to a <i>4x4</i> one while keeping contiguousness. Then, after the Matmul, the shifting must be undone to retrieve the original output shape.</p><div class="flex justify-center"><img class="w-full my-6 border-2 bg-white rounded" src="/autotune/offset.svg"></div><p>Couldn't we just prevent threads that are out of bound to do any computation, using an <code>if</code> statement? In a GPU kernel, it would not necessarily be the fastest way because an <code>if</code> will almost certainly create branch divergence. Still, that's what we do in our unpadded version of the tiling 2D algorithm. To be more precise, the conditional statement is at the stage where we load data to the shared memory, so that the <code>if</code> is only for reading and writing to global memory, while all computations operate without branching.</p><h3>Autotuning Matmul</h3><p>Now let's see what benchmarks have to say about which kernel is the best. While running the text classification training of Burn <!--#--><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-12-1" class="reference px-1">[<!--#--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-12-0" class="hover:text-[#69b8e1]" href="#reference-8">8</a><!--/-->]</span><!--/-->, I selected three examples from the autotune log. Again, the first line is the key and the last one is the winning kernel.</p><!--#--><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-13-0" class="py-2"><pre class="border-2 border-gray-900 shadow rounded-lg w-full max-w-full"><code id="harRim4dOuwEVylw-EnKC" class="language-">Matmul - Round:false Broadcast:false m:1024 k:256 n:256 batch:32
NaiveMemoryCoalescingMatmul&lt;f32, 3> => 12.58ms
PaddedTiling2DMatmul&lt;f32, 3> => 6.29ms
UnpaddedTiling2DMatmul&lt;f32, 3> => 3.93ms
Fastest: UnpaddedTiling2DMatmul&lt;f32, 3></code></pre></div><!--/--><!--#--><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-14-0" class="py-2"><pre class="border-2 border-gray-900 shadow rounded-lg w-full max-w-full"><code id="xk8NMLRqjFbF8RfyQqNQo" class="language-">Matmul - Round:true Broadcast:true m:256 k:1024 n:4 batch:32
NaiveMemoryCoalescingMatmul&lt;f32, 3> => 21.59ms
PaddedTiling2DMatmul&lt;f32, 3> => 5.04ms
UnpaddedTiling2DMatmul&lt;f32, 3> => 5.16ms
Fastest: PaddedTiling2Dmatmul&lt;f32, 3></code></pre></div><!--/--><!--#--><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-15-0" class="py-2"><pre class="border-2 border-gray-900 shadow rounded-lg w-full max-w-full"><code id="o32sgJvAaSEkTzvQbG7b6" class="language-">Matmul - Round:false Broadcast:false m:256 k:128 n:4 batch:32
NaiveMemoryCoalescingMatmul&lt;f32, 3> => 1.34ms
PaddedTiling2DMatmul&lt;f32, 3> => 1.43ms
UnpaddedTiling2DMatmul&lt;f32, 3> => 1.35ms
Fastest: NaiveMemoryCoalescingMatmul&lt;f32, 3></code></pre></div><!--/--><p>In the first example, the unpadded tiling version wins by a large margin. This is actually a common behaviour on my computer. For the padded version to win, it helps if the matrix is round, like in example 2. Still, it is won by a small margin. Finally, the third example shows the naive version winning, which typically happens on smaller inputs, a sign that the tiling algorithm overhead can be overkill.</p><h2>Conclusion</h2><p>In theory, it would be feasible to design an algorithm that chooses the right kernel as a function of the input size. However, the speed of a kernel for all input sizes can be hard to predict. Furthermore, some kernels are parameterizable, which means there are actually much more than two or three versions of an operation. But most of all, the GPU device on which the kernel runs adds many uncertainties: when run on some new device, what will be the GPU cache size? Will specialized accelerators be available? How many cores will work in parallel? How will memory coalescing actually occur?</p><p>Selecting the right kernel for an extensive AI model computation is an important decision that can save so much compute. But a perfect algorithm that answers the right thing on all machines would be too complex to be handcrafted. Autotune allows to write new kernels for specific scenarios without minding about the logistics of running that kernel.</p><p>One may worry about the induced overhead of running all kernels at the beginning. For applications where cold start is crucial, for instance in cloud applications where new instances spawn very often on the same machine to do similar jobs, our Autotune mechanism will rely on cached, pre-computed benchmarks. That way, using Autotune ensures peak performance in all settings.</p><h2>References</h2><!--#--><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-16"><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-17-0-0" id="reference-1"><span class="pr-2">[<!--#--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-17-0-1-0" link="true" target="_blank" href="https://www.youtube.com/watch?v=pdJQ8iVTwj8" class="hover:font-bold text-[#69b8e1] inactive" >1</a><!--/-->]</span><!--#-->Lex Fridman Podcast: Chris Lattner - Future of Programming and AI<!--/--></div><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-17-1-0" id="reference-2"><span class="pr-2">[<!--#--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-17-1-1-0" link="true" target="_blank" href="https://antarestech.com" class="hover:font-bold text-[#69b8e1] inactive" >2</a><!--/-->]</span><!--#-->Antares<!--/--></div><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-17-2-0" id="reference-3"><span class="pr-2">[<!--#--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-17-2-1-0" link="true" target="_blank" href="https://burn.dev/blog/creating-high-performance-asynchronous-backends-with-burn-compute" class="hover:font-bold text-[#69b8e1] inactive" >3</a><!--/-->]</span><!--#-->Creating High-Performance Asynchronous Backends with Burn-Compute<!--/--></div><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-17-3-0" id="reference-4"><span class="pr-2">[<!--#--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-17-3-1-0" link="true" target="_blank" href="https://www.w3.org/TR/WGSL/" class="hover:font-bold text-[#69b8e1] inactive" >4</a><!--/-->]</span><!--#-->WebGPU Shading Language<!--/--></div><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-17-4-0" id="reference-5"><span class="pr-2">[<!--#--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-17-4-1-0" link="true" target="_blank" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/" class="hover:font-bold text-[#69b8e1] inactive" >5</a><!--/-->]</span><!--#-->CUDA C Programming Guide<!--/--></div><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-17-5-0" id="reference-6"><span class="pr-2">[<!--#--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-17-5-1-0" link="true" target="_blank" href="https://www.diderot.one/courses/89/books/351/chapter/4547" class="hover:font-bold text-[#69b8e1] inactive" >6</a><!--/-->]</span><!--#-->Diderot: Divide and Conquer<!--/--></div><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-17-6-0" id="reference-7"><span class="pr-2">[<!--#--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-17-6-1-0" link="true" target="_blank" href="https://siboehm.com/articles/22/CUDA-MMM" class="hover:font-bold text-[#69b8e1] inactive" >7</a><!--/-->]</span><!--#-->How to Optimize a CUDA Matmul Kernel for cuBLAS-like Performance: a Worklog<!--/--></div><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-17-7-0" id="reference-8"><span class="pr-2">[<!--#--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-5-17-7-1-0" link="true" target="_blank" href="https://github.com/tracel-ai/burn/tree/main/examples/text-classification" class="hover:font-bold text-[#69b8e1] inactive" >8</a><!--/-->]</span><!--#-->Text classification on AG News in Burn<!--/--></div></div><!--/--></div><!--/--></div></article></div></div><!--/--><div class="w-full flex justify-center pt-10 pb-10 border-t-2 border-gray-900 mt-10"><div class="grid md:grid-cols-3 gap-x-16 gap-y-6 md:gap-x-60 bg-gray-800 text-gray-500"><ul data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-0" class="space-y-2"><h3 class="uppercase mb-2 font-bold">examples</h3><!--#--><li data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-1-0"><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-1-1-0" target="_blank" rel="noreferrer" href="https://github.com/tracel-ai/burn/tree/main/examples/mnist"><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-1-1-1" class="flex items-center"><!--#--><!--/--><!--#-->MNIST<!--/--></div></a></li><li data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-1-2"><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-1-3-0" target="_blank" rel="noreferrer" href="https://github.com/tracel-ai/burn/tree/main/examples/text-classification"><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-1-3-1" class="flex items-center"><!--#--><!--/--><!--#-->Text Classification<!--/--></div></a></li><li data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-1-4"><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-1-5-0" target="_blank" rel="noreferrer" href="https://github.com/tracel-ai/burn/tree/main/examples/onnx-inference"><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-1-5-1" class="flex items-center"><!--#--><!--/--><!--#-->ONNX Inference<!--/--></div></a></li><!--/--></ul><ul data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-2" class="space-y-2"><h3 class="uppercase mb-2 font-bold">community</h3><!--#--><li data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-3-0"><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-3-1-0" target="_blank" rel="noreferrer" href="https://github.com/tracel-ai/burn"><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-3-1-1" class="flex items-center"><!--#--><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-3-1-2" class="text-xl i-mdi-github mr-2"></div><!--/--><!--#-->Github<!--/--></div></a></li><li data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-3-2"><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-3-3-0" target="_blank" rel="noreferrer" href="https://discord.gg/uPEBbYYDB6"><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-3-3-1" class="flex items-center"><!--#--><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-3-3-2" class="text-xl i-mdi-discord mr-2"></div><!--/--><!--#-->Discord<!--/--></div></a></li><!--/--></ul><ul data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-4" class="space-y-2"><h3 class="uppercase mb-2 font-bold">about</h3><!--#--><li data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-5-0"><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-5-1-0" target="_blank" rel="noreferrer" href="https://burn.dev/docs/burn"><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-5-1-1" class="flex items-center"><!--#--><!--/--><!--#-->Documentation<!--/--></div></a></li><li data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-5-2"><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-5-3-0" target="_blank" rel="noreferrer" href="/book"><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-5-3-1" class="flex items-center"><!--#--><!--/--><!--#-->Book<!--/--></div></a></li><li data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-5-4"><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-5-5-0" target="_blank" rel="noreferrer" href="https://crates.io/crates/burn"><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-5-5-1" class="flex items-center"><!--#--><!--/--><!--#-->Crates.io<!--/--></div></a></li><li data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-5-6"><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-5-7-0" target="_blank" rel="noreferrer" href="https://github.com/tracel-ai/burn#license"><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-1-1-0-0-0-6-5-7-1" class="flex items-center"><!--#--><!--/--><!--#-->License<!--/--></div></a></li><!--/--></ul></div></div></div><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0-2-0" style="position:fixed;z-index:9999;top:16px;bottom:16px;left:16px;right:16px;pointer-events:none" class=""><style>.sldt-active{z-index:9999;}.sldt-active>*{pointer-events:auto;}</style><!--#--><!--/--></div></div><!/e0-0-0-0-0-0-0-0-0-1-0-0-0><script>(e=>{let t=e=>e&&e.hasAttribute&&(e.hasAttribute("data-hk")?e:t(e.host&&e.host instanceof Node?e.host:e.parentNode));["click", "input"].forEach((o=>document.addEventListener(o,(o=>{let s=o.composedPath&&o.composedPath()[0]||o.target,a=t(s);a&&!e.completed.has(a)&&e.events.push([a,o])}))))})(window._$HY||(_$HY={events:[],completed:new WeakSet,r:{},fe(){},init(e,t){_$HY.r[e]=[new Promise((e=>t=e)),t]},set(e,t,o){(o=_$HY.r[e])&&o[1](t),_$HY.r[e]=[t]},unset(e){delete _$HY.r[e]},load:e=>_$HY.r[e]}));</script><!--xs--><script type="module" async src="/assets/entry-client-19a0a2a8.js"></script></body></html>